#!/usr/bin/env bash
# /usr/bin/newpkg - unified CLI for newpkg (final)
# Save with: sudo tee /usr/bin/newpkg > /dev/null <<'EOF' ... EOF
set -o errexit
set -o nounset
set -o pipefail
IFS=$'\n\t'

VERSION="1.0.0"
BASE_SHARE="/usr/share/newpkg"
LIB_DIR="${BASE_SHARE}/lib"
CORE_SH="${CORE_SH:-${LIB_DIR}/core.sh}"
DB_SH="${DB_SH:-${LIB_DIR}/db.sh}"
LOG_SH="${LOG_SH:-${LIB_DIR}/log.sh}"
DEPS_PY="${DEPS_PY:-${LIB_DIR}/deps.py}"
REVDEP_SH="${REVDEP_SH:-${LIB_DIR}/revdep_depclean.sh}"
REMOVE_SH="${REMOVE_SH:-${LIB_DIR}/remove.sh}"
UPGRADE_SH="${UPGRADE_SH:-${LIB_DIR}/upgrade.sh}"
BOOTSTRAP_SH="${BOOTSTRAP_SH:-${LIB_DIR}/bootstrap.sh}"
AUDIT_SH="${AUDIT_SH:-${LIB_DIR}/newpkg_audit.sh}"
SYNC_SH="${SYNC_SH:-${LIB_DIR}/sync.sh}"

ETC_DIR="${ETC_DIR:-/etc/newpkg}"
CONFIG_FILE="${CONFIG_FILE:-${ETC_DIR}/newpkg.yaml}"
LOG_DIR="${LOG_DIR:-/var/log/newpkg}"
CACHE_DIR="${CACHE_DIR:-/var/cache/newpkg}"
PORTS_DIR="${PORTS_DIR:-/usr/ports}"
BACKUP_DIR="${BACKUP_DIR:-/var/backups/newpkg}"
LFS_ROOT="${LFS_ROOT:-/mnt/lfs}"

YQ="$(command -v yq || true)"
JQ="$(command -v jq || true)"
TPUT="$(command -v tput || true)"

DRY_RUN=0
QUIET=0
AUTO=0
COMMAND=""
ARGS=()

if [[ -n "$TPUT" && -t 1 ]]; then
  NC="$(tput sgr0)"; RED="$(tput setaf 1)"; GREEN="$(tput setaf 2)"
  YELLOW="$(tput setaf 3)"; BLUE="$(tput setaf 4)"; BOLD="$(tput bold)"
else
  NC=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; BOLD=""
fi

_log_local() {
  local level="$1"; shift; local msg="$*"; local ts; ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  printf '%s [%s] %s\n' "$ts" "$level" "$msg"
  mkdir -p "$LOG_DIR"
  printf '%s [%s] %s\n' "$ts" "$level" "$msg" >> "$LOG_DIR/newpkg.log"
}
info()  { [[ $QUIET -eq 0 ]] && _log_local "INFO" "$*"; }
warn()  { _log_local "WARN" "$*"; }
error() { _log_local "ERROR" "$*"; }
cprint(){ local c="$1"; shift; printf "%b%s%b\n" "$c" "$*" "$NC"; }
die(){ error "$*"; exit 1; }
sr(){ if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) $*"; else eval "$*"; fi }

read_config(){
  if [[ -n "$YQ" && -f "$CONFIG_FILE" ]]; then
    PARALLEL="$(yq e '.parallel_jobs // 1' "$CONFIG_FILE" 2>/dev/null || echo 1)"
    DEFAULT_STAGE="$(yq e '.default_stage // "normal"' "$CONFIG_FILE" 2>/dev/null || echo "normal")"
    CACHE_DIR_CFG="$(yq e '.cache_dir // ""' "$CONFIG_FILE" 2>/dev/null || echo "")"
    [[ -n "$CACHE_DIR_CFG" && "$CACHE_DIR_CFG" != "null" ]] && CACHE_DIR="$CACHE_DIR_CFG"
  else
    PARALLEL=1; DEFAULT_STAGE="normal"
  fi
}

ensure_dirs(){
  local dirs=( "$ETC_DIR" "$LOG_DIR" "$CACHE_DIR" "$CACHE_DIR/sources" "$CACHE_DIR/packages" "$BACKUP_DIR" "$PORTS_DIR" "$BASE_SHARE/hooks" "/usr/share/newpkg/stages" )
  for d in "${dirs[@]}"; do
    if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) mkdir -p $d"; else mkdir -p -- "$d"; chmod 0755 "$d" || true; fi
  done
}

create_default_config(){
  local cfg="$CONFIG_FILE"
  if [[ -f "$cfg" ]]; then info "Config exists: $cfg"; return 0; fi
  mkdir -p "$(dirname "$cfg")"
  cat > "$cfg" <<EOF
parallel_jobs: $(nproc 2>/dev/null || echo 1)
default_stage: normal
cache_dir: $CACHE_DIR
repo_dir: $PORTS_DIR
log_dir: $LOG_DIR
chroot_dir: $LFS_ROOT
colors: true
safe_chroot: true
EOF
  chmod 0644 "$cfg"
  info "Created: $cfg"
}

install_shortcuts(){
  for s in np pkg npg; do
    local dest="/usr/bin/$s"
    if [[ -e "$dest" ]]; then info "Shortcut $dest exists"; continue; fi
    if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) ln -s /usr/bin/newpkg $dest"; else ln -sf /usr/bin/newpkg "$dest"; fi
  done
}

check_prereqs(){
  local miss=(); for cmd in jq tar sha256sum curl git yq zstd fakeroot; do if ! command -v "$cmd" >/dev/null 2>&1; then miss+=( "$cmd" ); fi; done
  if [[ ${#miss[@]} -gt 0 ]]; then warn "Missing tools: ${miss[*]}. Some features limited."; fi
}

list_installed(){
  if [[ -x "$DB_SH" ]]; then
    if [[ -n "$JQ" ]]; then "$DB_SH" list --json 2>/dev/null | jq -r '.[] | "\(.name) \(.version) \(.install_date // "")"' || true
    else "$DB_SH" list || true
    fi
  else
    warn "db.sh missing; fallback best-effort"
    ls /usr/bin | head -n 200
  fi
}

list_ports_highlighted(){
  declare -A INSTALLED=()
  if [[ -x "$DB_SH" && -n "$JQ" ]]; then mapfile -t arr < <("$DB_SH" list --json 2>/dev/null | jq -r '.[].name' 2>/dev/null || true); for v in "${arr[@]}"; do INSTALLED["$v"]=1; done; fi
  if [[ -n "$YQ" ]]; then
    find "$PORTS_DIR" -maxdepth 4 -type f \( -iname 'metafile.yaml' -o -iname 'meta.yaml' \) -print0 2>/dev/null | \
    xargs -0 -n1 -P4 bash -c '
      f="$0"
      nm="$('"$YQ"' e '\''.name // .package // .pkgname // ""'\'' "$f" 2>/dev/null)"
      ver="$('"$YQ"' e '\''.version // ""'\'' "$f" 2>/dev/null)"
      if [[ -z "$nm" || "$nm" == "null" ]]; then nm="$(basename "$(dirname "$f")")"; fi
      printf "%s\t%s\t%s\n" "$nm" "$ver" "$f"
    '
  else
    find "$PORTS_DIR" -mindepth 2 -maxdepth 2 -type d 2>/dev/null | sed -E 's!.*/([^/]+)/([^/]+)$!\2\t\1!' | sort -u
  fi | while IFS=$'\t' read -r name ver file; do
    if [[ -n "${INSTALLED[$name]:-}" ]]; then printf "%b%-24s%b %s\n" "$GREEN" "$name" "$NC" "${ver:-}"; else printf "%-24s %s\n" "$name" "${ver:-}"; fi
  done
}

search_ports(){
  local term="$1"; [[ -n "$term" ]] || die "search term required"
  if [[ -n "$YQ" ]]; then
    find "$PORTS_DIR" -type f -name '*.yaml' -o -name '*.yml' -print0 2>/dev/null | xargs -0 -n1 -P4 bash -c '
      f="$0"
      if '"$YQ"' e -e "to_entries | tostring | contains(\"'"$term"'\")" "$f" >/dev/null 2>&1; then
        nm="$('"$YQ"' e '\''.name // .package // .pkgname // ""'\'' "$f" 2>/dev/null)"
        ver="$('"$YQ"' e '\''.version // ""'\'' "$f" 2>/dev/null)"
        printf "%s\t%s\t%s\n" "$nm" "$ver" "$f"
      fi
    '
  else
    grep -R --line-number -i "$term" "$PORTS_DIR" 2>/dev/null | head -n 200 || true
  fi
}

show_package_info(){
  local pkg="$1"; [[ -n "$pkg" ]] || die "package required"
  if [[ -n "$YQ" ]]; then
    local mf
    mf="$(find "$PORTS_DIR" -type f \( -iname '*.yaml' -o -iname '*.yml' \) -exec grep -l -E "^name:.*${pkg}\$|^package:.*${pkg}\$" {} + 2>/dev/null | head -n1 || true)"
    if [[ -n "$mf" ]]; then cprint "$BLUE" "Metafile: $mf"; yq e '.' "$mf" || true; return 0; fi
  fi
  if [[ -x "$DB_SH" ]]; then "$DB_SH" query "$pkg" && return 0 || true; fi
  warn "No metadata for $pkg"
  return 1
}

# actions
action_install(){
  local pkgs=( "$@" ); [[ ${#pkgs[@]} -gt 0 ]] || die "no packages"
  if [[ -x "$DEPS_PY" ]]; then
    info "Resolving deps..."
    if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) deps.py resolve ${pkgs[*]}"; else "$DEPS_PY" resolve "${pkgs[@]}" || warn "deps.py returned nonzero"; fi
  fi
  for p in "${pkgs[@]}"; do
    info "Install: $p"
    if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) core.sh install $p"; else
      if [[ -x "$CORE_SH" ]]; then CORE_STAGE="${DEFAULT_STAGE:-normal}" "$CORE_SH" install "$p"; else die "core.sh not found at $CORE_SH"; fi
    fi
  done
}

action_remove(){
  local pkgs=( "$@" ); [[ ${#pkgs[@]} -gt 0 ]] || die "no packages"
  for p in "${pkgs[@]}"; do info "Removing: $p"; if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) remove $p"; else if [[ -x "$REMOVE_SH" ]]; then "$REMOVE_SH" "$p"; else die "remove.sh missing"; fi; fi; done
}

action_upgrade(){ local args=( "$@" ); if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) upgrade ${args[*]}"; else if [[ -x "$UPGRADE_SH" ]]; then "$UPGRADE_SH" "${args[@]}"; else die "upgrade.sh missing"; fi; fi }

action_sync(){ if [[ $DRY_RUN -eq 1 ]]; then info "(dry-run) sync"; else if [[ -x "$SYNC_SH" ]]; then "$SYNC_SH" "$@"; else warn "sync.sh missing"; fi; fi }

action_deps(){ if [[ -x "$DEPS_PY" ]]; then "$DEPS_PY" "$@"; else warn "deps.py missing"; fi }

action_audit(){ if [[ -x "$AUDIT_SH" ]]; then "$AUDIT_SH" "$@"; else warn "audit.sh missing"; fi }

action_bootstrap(){ if [[ -x "$BOOTSTRAP_SH" ]]; then "$BOOTSTRAP_SH" "$@"; else warn "bootstrap.sh missing"; fi }

action_revdep(){ if [[ -x "$REVDEP_SH" ]]; then "$REVDEP_SH" "$@"; else warn "revdep missing"; fi }

action_query(){ show_package_info "$1"; }

action_list_installed(){ info "Installed:"; list_installed | while IFS= read -r line; do cprint "$GREEN" "$line"; done }

action_ports(){ info "Repo packages:"; list_ports_highlighted }

action_search(){ search_ports "$1"; }

action_init(){ info "Initializing..."; ensure_dirs; create_default_config; install_shortcuts; check_prereqs; info "Done." }

action_show_audit_log(){ if [[ -f "$LOG_DIR/newpkg.log" ]]; then tail -n 200 "$LOG_DIR/newpkg.log"; else warn "no logs"; fi }

# simple menu (same as earlier but trimmed)
show_menu(){
  while true; do
    clear; cprint "$BOLD" "newpkg (v${VERSION})"; echo "1) Install  2) Remove  3) Upgrade  4) List installed  5) Ports  6) Search  7) Info  8) Sync 9) Audit 10) Bootstrap 11) Init 0) Exit"
    read -r -p "Choice: " ch
    case "$ch" in
      1) read -r -p "Pkgs: " str; set -- $str; action_install "$@"; read -r -p "Press enter";;
      2) read -r -p "Pkgs: " str; set -- $str; action_remove "$@"; read -r -p "Press enter";;
      3) read -r -p "Pkgs (or blank all): " str; if [[ -z "$str" ]]; then action_upgrade --all; else set -- $str; action_upgrade "$@"; fi; read -r -p "Press enter";;
      4) action_list_installed; read -r -p "Press enter";;
      5) action_ports; read -r -p "Press enter";;
      6) read -r -p "Term: " t; action_search "$t"; read -r -p "Press enter";;
      7) read -r -p "Package: " p; action_query "$p"; read -r -p "Press enter";;
      8) action_sync; read -r -p "Press enter";;
      9) action_audit; read -r -p "Press enter";;
      10) read -r -p "Stage(pass1|pass2|final|all): " s; if [[ "$s" == "all" ]]; then action_bootstrap --all; else action_bootstrap --run "$s"; fi; read -r -p "Press enter";;
      11) action_init; read -r -p "Press enter";;
      0) exit 0;;
      *) echo "Invalid";;
    esac
  done
}

# parse CLI
usage(){
  cat <<EOF
newpkg CLI

Usage: newpkg [options] command

Common:
  -n --dry-run   simulate
  -q --quiet
  -i|--install PKG...
  -r|--remove PKG...
  -u|--upgrade [PKG...]
  -s|--sync
  -b|--bootstrap
  -d|--deps
  -a|--audit
  --init
  --menu
EOF
  exit 1
}

COMMAND=""; ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--dry-run) DRY_RUN=1; shift ;;
    -q|--quiet) QUIET=1; shift ;;
    --auto) AUTO=1; shift ;;
    --menu) COMMAND="menu"; shift ;;
    -i|--install) COMMAND="install"; shift; while [[ $# -gt 0 && "$1" != "-"* ]]; do ARGS+=( "$1" ); shift; done ;;
    -r|--remove) COMMAND="remove"; shift; while [[ $# -gt 0 && "$1" != "-"* ]]; do ARGS+=( "$1" ); shift; done ;;
    -u|--upgrade) COMMAND="upgrade"; shift; while [[ $# -gt 0 && "$1" != "-"* ]]; do ARGS+=( "$1" ); shift; done ;;
    -s|--sync) COMMAND="sync"; shift ;;
    -b|--bootstrap) COMMAND="bootstrap"; shift; ARGS+=( "$1" ); shift ;;
    -d|--deps) COMMAND="deps"; shift; while [[ $# -gt 0 && "$1" != "-"* ]]; do ARGS+=( "$1" ); shift; done ;;
    -a|--audit) COMMAND="audit"; shift; while [[ $# -gt 0 && "$1" != "-"* ]]; do ARGS+=( "$1" ); shift; done ;;
    -l|--list) COMMAND="list"; shift ;;
    -p|--ports) COMMAND="ports"; shift ;;
    --search) COMMAND="search"; shift; ARGS+=( "$1" ); shift ;;
    --query) COMMAND="query"; shift; ARGS+=( "$1" ); shift ;;
    --revdep) COMMAND="revdep"; shift ;;
    --depclean) COMMAND="depclean"; shift ;;
    --init) COMMAND="init"; shift ;;
    --resume) ARGS+=( "--resume" ); shift ;;
    --audit-log) COMMAND="audit-log"; shift ;;
    --version) echo "newpkg $VERSION"; exit 0 ;;
    --help|-h) usage; exit 0 ;;
    *) if [[ -z "$COMMAND" ]]; then COMMAND="install"; ARGS+=( "$1" ); shift; else ARGS+=( "$1" ); shift; fi ;;
  esac
done

read_config

case "$COMMAND" in
  ""|"menu") show_menu ;;
  install) action_install "${ARGS[@]}" ;;
  remove) action_remove "${ARGS[@]}" ;;
  upgrade) action_upgrade "${ARGS[@]}" ;;
  sync) action_sync "${ARGS[@]}" ;;
  deps) action_deps "${ARGS[@]}" ;;
  audit) action_audit "${ARGS[@]}" ;;
  bootstrap) action_bootstrap "${ARGS[@]}" ;;
  revdep) action_revdep "${ARGS[@]}" ;;
  depclean) action_revdep --depclean "${ARGS[@]}" ;;
  list) action_list_installed ;;
  ports) action_ports ;;
  search) action_search "${ARGS[0]:-}" ;;
  query) action_query "${ARGS[0]:-}" ;;
  init) action_init ;;
  "audit-log") action_show_audit_log ;;
  *) usage; exit 1 ;;
esac
